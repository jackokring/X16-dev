// THE BASE LIBRARY

// Useful routines not specific to anything but always useful

//===========================================================
// BANKING
//===========================================================
void kernal() {
    poke($9F60, 0)
}

void BASIC() {
    poke($9F60, 4) //basic
}

byte ramBank(byte b) {
    byte old
    old = peek($9F61)
    poke($9F61, b)
    return old
}

//===========================================================
// INIT AND CLEAN
//===========================================================
void initGeneral() {
    kernal()
    ramBank(0)
    poke($9F25, 0) //init VERA 0
    vinit(512, 448, 0) //set visible area

}

void shutdownGeneral() {
    BASIC()

    asm {
        jmp ($FFFC) //reset
    }
}

//===========================================================
// VERA LOW LEVEL VIDEO (uses 17:1 bit aligned word refs)
//===========================================================
inline byte signlo(byte b) {
    if b < 0 {
        return 1
    }
    return 0
}

inline byte lsbhi(byte b) {
    if (b & 1) != 0 {
        return $80
    }
    return 0
}

void vaddr(word low) {//for main display word aligned
    poke($9F20, low.lo << 1) 
    poke($9F21, (low.hi << 1) | signlo(low.lo))
    poke($9F22, signlo(low.hi) | $10) //128 kB high bit step of 1
}

void caddr(word low) {//for palette and other VERA
    vaddr(low)
    poke($9F22, $1F) //and access all high ram aligned word
}

void voke(word w) {
    poke($9F23, w.lo) //poke VERA port
    poke($9F23, w.hi) //and the high byte
}

void bvoke(byte b) {
    poke($9F23, b)
}

const byte geo8by8 = $0
const byte geo16by16 = $3
const byte geoMap32by32 = $0
const byte geoMap64by64 = $A

const byte geoBig = geoMap32by32 + ((geo16by16) << 4)
const byte geoSmall = geoMap64by64 + ((geo8by8) << 4)

const byte geo4bppMap = $3

void setlayer(byte layer, byte mode, byte geo, word map, word tile) {
    word base = $1000
    if layer != 0 {
        base += $800
    }
    caddr(base) //ready
    bvoke((mode << 5) + 1) //set
    bvoke(geo)
    bvoke(((map.lo) >> 1) + lsbhi(map.hi))
    bvoke(map.hi)
    bvoke(((tile.lo) >> 1) + lsbhi(tile.hi))
    bvoke(tile.hi)
    voke(0) //scroll H
    voke(0) //scroll V
}

void setscroll(byte layer, word x, word y) {
    word base = $1000 + $6 //directly to scroll registers
    if layer != 0 {
        base += $800
    }
    caddr(base)
    voke(x)
    voke(y)
}

//===========================================================
// VERA HIGH LEVEL VIDEO
//===========================================================
void vinit(word w, word h, byte bord) {
    caddr(0)
    peek($9F23) //read over
    voke($8080) //basic 1:1 pixel clock scaling (maybe later)
    bvoke(bord) //set border
    word hw = (640 - w) >> 1
    bvoke(hw.lo) //start
    byte hibit = ((hw.hi + w.hi) << 2) + hw.hi//put high bit in
    bvoke(hw.lo + w.lo) //stop modulo
    hw = (480 - h) >> 1
    word irq = hw + h
    bvoke(hw.lo) //start
    bvoke(hw.lo + h.lo) //stop
    hibit = ((((hw.hi + h.hi) << 1) + hw.hi) << 4) + hibit
    bvoke(hibit) //the high bits of the range
    //IRQ?
    voke(irq) //set irq line
}

void setpal(byte idx, byte r, byte g, byte b) {
    caddr($800 + idx) //word aligned
    bvoke((r << 4) & g)
    bvoke(b) //and maybe alpha later?
}

